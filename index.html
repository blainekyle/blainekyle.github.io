<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Rainbow Shapes Wallpaper</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
        }
    </style>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <canvas id="wallpaperCanvas"></canvas>
    <div id="customAlertBox" class="message-box"></div>

    <script>
        // --- Canvas Setup ---
        const canvas = document.getElementById('wallpaperCanvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        // --- Configuration ---
        const PARTICLE_COUNT_MOUSE = 5;
        const PARTICLE_LIFESPAN_MOUSE = 216; 
        const PARTICLE_SPEED_MOUSE_MULTIPLIER = 0.2; 
        const PARTICLE_LIFESPAN_IDLE_RANDOM = 200; // Shorter life for random ones, shapes will get new life
        const PARTICLE_BASE_SIZE = 4; // Slightly smaller base size
        const MOUSE_INACTIVITY_TIMEOUT = 4000; // ms
        const IDLE_DROPLET_SPAWN_INTERVAL = 70; // ms (more frequent for more particles)
        
        const SHAPE_FORMATION_DELAY = 4000; // ms after idle starts
        const NUM_SHAPES_TO_FORM = 10; // Number of shapes to attempt to form
        const PARTICLES_PER_SHAPE_TARGET = 40; // Target particles per shape
        const SHAPE_LIFESPAN_MULTIPLIER = 4.0; // Lifespan for shape particles
        const SPARKLE_CHANCE_SHAPE = 0.3; // Sparkle chance for shape particles

        const SHAPE_SCALE = 1.5; // Scale for drawing shapes
        const SHAPE_SLOW_SPIN_DURATION = 300; // frames (5s at 60fps)
        const SHAPE_FAST_SPIN_DURATION = 180; // frames (3s at 60fps)
        const SHAPE_SPIN_SPEED_SLOW = 0.005; // radians per frame
        const SHAPE_SPIN_SPEED_FAST = 0.025; // radians per frame
        const SHAPE_DISINTEGRATE_SPEED = 1.5;

        // --- Global State ---
        let particles = []; // All active particles
        let activeShapes = []; // Stores active shape objects
        let hue = 0;
        let mouseX = width / 2;
        let mouseY = height / 2;
        let lastMouseMoveTime = Date.now();
        let isIdleMode = false;
        let idleDropletTimer = null;
        let shapeFormationTimeoutId = null;

        // --- Basic Shape Definitions (centered at 0,0) ---
        const basicShapeTemplates = [
            { // Triangle
                name: 'triangle',
                points: [{x: 0, y: -15}, {x: 13, y: 7.5}, {x: -13, y: 7.5}]
            },
            { // Square
                name: 'square',
                points: [{x: -10, y: -10}, {x: 10, y: -10}, {x: 10, y: 10}, {x: -10, y: 10}]
            },
            { // Circle (8-point approximation)
                name: 'circle',
                points: [
                    {x:0,y:-12},{x:8.5,y:-8.5},{x:12,y:0},{x:8.5,y:8.5},
                    {x:0,y:12},{x:-8.5,y:8.5},{x:-12,y:0},{x:-8.5,y:-8.5}
                ]
            },
            { // Cross
                name: 'cross',
                points: [
                    {x: -3, y: -10}, {x: 3, y: -10}, {x: 3, y: -3}, {x: 10, y: -3}, 
                    {x: 10, y: 3}, {x: 3, y: 3}, {x: 3, y: 10}, {x: -3, y: 10}, 
                    {x: -3, y: 3}, {x: -10, y: 3}, {x: -10, y: -3}, {x: -3, y: -3}
                ]
            },
            { // Simple Star (5 points)
                name: 'star',
                points: [
                    {x: 0, y: -15}, {x: 4.4, y: -4.6}, {x: 14.3, y: -4.6}, {x: 7, y: 2.3},
                    {x: 8.8, y: 12.1}, {x: 0, y: 7.5}, {x: -8.8, y: 12.1}, {x: -7, y: 2.3},
                    {x: -14.3, y: -4.6}, {x: -4.4, y: -4.6}
                ]
            }
        ];

        // --- Utility: Show custom message ---
        function showMessage(message, duration = 3000) {
            const alertBox = document.getElementById('customAlertBox');
            if (alertBox) {
                alertBox.textContent = message;
                alertBox.style.display = 'block';
                setTimeout(() => { alertBox.style.display = 'none'; }, duration);
            } else { console.log("Message (fallback):", message); }
        }

        // --- Particle Class ---
        class Particle {
            constructor(x, y, color, size, type = 'mouse') {
                this.x = x;
                this.y = y;
                this.size = Math.random() * size + PARTICLE_BASE_SIZE / 2;
                this.initialSize = this.size;
                this.color = {...color}; 
                this.type = type; // 'mouse', 'idle_random', 'shape_forming', 'shape_active'
                this.opacity = 1;
                this.isSparkle = false;
                this.sparkleSeed = Math.random() * 100;
                this.shapeTargetX = 0; // For 'shape_forming'
                this.shapeTargetY = 0; // For 'shape_forming'
                this.isAtShapeTarget = false;
                this.formationSpeed = Math.random() * 0.04 + 0.02; // Speed to reach shape point
                this.shapePointRelX = 0; // Relative X in shape after formation
                this.shapePointRelY = 0; // Relative Y in shape after formation
                this.parentShape = null; // Reference to its ShapeObject

                if (this.type === 'mouse') {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random() * 2.5 + 0.5) * PARTICLE_SPEED_MOUSE_MULTIPLIER;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.life = PARTICLE_LIFESPAN_MOUSE + Math.random() * 40;
                } else if (this.type === 'idle_random') {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 1.5 + 0.3; // Slower random drift
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.life = PARTICLE_LIFESPAN_IDLE_RANDOM + Math.random() * 40;
                } else if (this.type === 'shape_forming' || this.type === 'shape_active') {
                    this.vx = 0; this.vy = 0;
                    this.life = PARTICLE_LIFESPAN_IDLE_RANDOM * SHAPE_LIFESPAN_MULTIPLIER; // Longer life for shape particles
                    this.isSparkle = Math.random() < SPARKLE_CHANCE_SHAPE;
                    if(this.isSparkle) this.color.l = Math.min(100, this.color.l + 25);
                } else { 
                    this.vx = 0; this.vy = 0;
                    this.life = PARTICLE_LIFESPAN_IDLE_RANDOM;
                }
                this.initialLife = this.life;
            }

            update() {
                this.life--;
                const lifeRatio = Math.max(0, this.life / this.initialLife);
                this.opacity = lifeRatio;
                let currentBaseSize = this.initialSize * lifeRatio;

                if (this.type === 'mouse' || this.type === 'idle_random') {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= 0.97; // Slightly more friction
                    this.vy *= 0.97;
                    this.size = currentBaseSize;
                } else if (this.type === 'shape_forming') {
                    if (!this.isAtShapeTarget) {
                        const dx = this.shapeTargetX - this.x;
                        const dy = this.shapeTargetY - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 1) {
                            this.x += (dx / dist) * Math.min(dist, dist * this.formationSpeed);
                            this.y += (dy / dist) * Math.min(dist, dist * this.formationSpeed);
                        } else {
                            this.isAtShapeTarget = true;
                            this.x = this.shapeTargetX; this.y = this.shapeTargetY;
                            if (this.parentShape) this.parentShape.checkIfFormed();
                        }
                    }
                    // Position will be controlled by ShapeObject once formed and spinning
                } else if (this.type === 'shape_active') {
                    // Position is dictated by the parent ShapeObject's rotation and disintegration
                    if (this.parentShape && this.parentShape.state === 'disintegrating') {
                         this.x += this.vx;
                         this.y += this.vy;
                         this.vx *= 0.98; // Slow down disintegration
                         this.vy *= 0.98;
                    }
                }


                if (this.isSparkle && (this.type === 'shape_forming' || this.type === 'shape_active')) {
                    this.opacity = lifeRatio * (0.7 + Math.sin(Date.now() * 0.025 + this.sparkleSeed) * 0.3);
                    this.size = currentBaseSize * (1 + Math.sin(Date.now() * 0.035 + this.sparkleSeed + 50) * 0.25);
                } else {
                    this.size = currentBaseSize;
                }
            }

            draw() {
                if (this.size <= 0.1 || this.opacity <= 0) return;
                ctx.beginPath();
                ctx.arc(this.x, this.y, Math.max(0.1, this.size), 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${this.color.h}, ${this.color.s}%, ${this.color.l}%, ${this.opacity})`;
                ctx.fill();
            }
        }

        // --- Shape Object Class ---
        class ShapeObject {
            constructor(x, y, shapeTemplate, initialHue) {
                this.anchorX = x;
                this.anchorY = y;
                this.template = shapeTemplate;
                this.particles = []; // Particles belonging to this shape
                this.state = 'forming'; // 'forming', 'spinning_slow', 'spinning_fast', 'disintegrating', 'done'
                this.currentAngle = Math.random() * Math.PI * 2; // Initial random orientation
                this.spinSpeed = 0;
                this.age = 0; // Frames since fully formed
                this.baseHue = initialHue;
            }

            addParticle(particle, targetRelX, targetRelY) {
                particle.parentShape = this;
                particle.type = 'shape_forming';
                particle.shapePointRelX = targetRelX; // Store relative coords for spinning
                particle.shapePointRelY = targetRelY;

                // Calculate absolute target for formation
                const rotatedX = targetRelX * Math.cos(this.currentAngle) - targetRelY * Math.sin(this.currentAngle);
                const rotatedY = targetRelX * Math.sin(this.currentAngle) + targetRelY * Math.cos(this.currentAngle);
                particle.shapeTargetX = this.anchorX + rotatedX * SHAPE_SCALE;
                particle.shapeTargetY = this.anchorY + rotatedY * SHAPE_SCALE;
                
                particle.isAtShapeTarget = false; // Reset for formation
                particle.life = PARTICLE_LIFESPAN_IDLE_RANDOM * SHAPE_LIFESPAN_MULTIPLIER;
                particle.initialLife = particle.life;
                this.particles.push(particle);
            }
            
            checkIfFormed() {
                if (this.state !== 'forming') return;
                if (this.particles.length < PARTICLES_PER_SHAPE_TARGET * 0.7) return; // Need most particles

                for (const p of this.particles) {
                    if (!p.isAtShapeTarget) return;
                }
                this.state = 'spinning_slow';
                this.spinSpeed = SHAPE_SPIN_SPEED_SLOW;
                this.particles.forEach(p => p.type = 'shape_active'); // Transition particle type
            }

            update() {
                if (this.state === 'done') return;
                this.age++;

                if (this.state === 'spinning_slow') {
                    this.currentAngle += this.spinSpeed;
                    if (this.age > SHAPE_SLOW_SPIN_DURATION) {
                        this.state = 'spinning_fast';
                        this.spinSpeed = SHAPE_SPIN_SPEED_FAST;
                        this.age = 0; // Reset age for this state
                    }
                } else if (this.state === 'spinning_fast') {
                    this.currentAngle += this.spinSpeed;
                    if (this.age > SHAPE_FAST_SPIN_DURATION) {
                        this.state = 'disintegrating';
                        this.disintegrate();
                    }
                } else if (this.state === 'disintegrating') {
                    // Particles fly out, handled by particle.update()
                    // Check if all particles are faded
                    let allFaded = true;
                    for (const p of this.particles) {
                        if (p.life > 0) {
                            allFaded = false;
                            break;
                        }
                    }
                    if (allFaded) this.state = 'done';
                }

                // Update particle positions if spinning
                if (this.state === 'spinning_slow' || this.state === 'spinning_fast') {
                    for (const p of this.particles) {
                        const rotatedX = p.shapePointRelX * Math.cos(this.currentAngle) - p.shapePointRelY * Math.sin(this.currentAngle);
                        const rotatedY = p.shapePointRelX * Math.sin(this.currentAngle) + p.shapePointRelY * Math.cos(this.currentAngle);
                        p.x = this.anchorX + rotatedX * SHAPE_SCALE;
                        p.y = this.anchorY + rotatedY * SHAPE_SCALE;
                    }
                }
            }

            disintegrate() {
                for (const p of this.particles) {
                    p.life = Math.min(p.life, PARTICLE_LIFESPAN_IDLE_RANDOM / 2); // Shorten life
                    const angle = Math.atan2(p.y - this.anchorY, p.x - this.anchorX) + (Math.random() -0.5) * 0.5;
                    const speed = SHAPE_DISINTEGRATE_SPEED + Math.random();
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                }
            }
        }

        // --- Event Handlers ---
        function handleMouseMove(event) {
            mouseX = event.clientX;
            mouseY = event.clientY;
            lastMouseMoveTime = Date.now();

            if (isIdleMode) {
                isIdleMode = false;
                clearTimeout(shapeFormationTimeoutId);
                if (idleDropletTimer) clearInterval(idleDropletTimer);
                
                // If shapes are active, make them disintegrate faster
                activeShapes.forEach(shape => {
                    if (shape.state !== 'disintegrating' && shape.state !== 'done') {
                        shape.state = 'disintegrating';
                        shape.disintegrate(); // Trigger immediate disintegration logic
                        shape.particles.forEach(p => p.life = Math.min(p.life, PARTICLE_LIFESPAN_IDLE_RANDOM / 3));
                    }
                });
            }

            hue = (hue + 5) % 360;
            for (let i = 0; i < PARTICLE_COUNT_MOUSE; i++) {
                particles.push(new Particle(mouseX, mouseY, {h: (hue + i*10) % 360, s: 100, l: 70}, PARTICLE_BASE_SIZE * 1.2, 'mouse'));
            }
        }
        function handleResize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        // --- Idle Mode Logic ---
        function checkIdleStatus() {
            if (Date.now() - lastMouseMoveTime > MOUSE_INACTIVITY_TIMEOUT && !isIdleMode) {
                isIdleMode = true;
                startIdleDroplets();
                clearTimeout(shapeFormationTimeoutId);
                shapeFormationTimeoutId = setTimeout(startShapesFormation, SHAPE_FORMATION_DELAY);
            }
        }

        function startIdleDroplets() {
            if (idleDropletTimer) clearInterval(idleDropletTimer);
            idleDropletTimer = setInterval(() => {
                if (!isIdleMode || activeShapes.some(s => s.state !== 'done')) return; // Only spawn if truly idle

                const x = Math.random() * width;
                const y = Math.random() * height;
                const randomHue = Math.random() * 360;
                particles.push(new Particle(x, y, {h: randomHue, s: 90, l: 60}, PARTICLE_BASE_SIZE * 0.9, 'idle_random'));
            }, IDLE_DROPLET_SPAWN_INTERVAL);
        }

        function startShapesFormation() {
            if (!isIdleMode || activeShapes.some(s => s.state !== 'done' && s.state !== 'disintegrating')) return;
            
            activeShapes = []; // Clear old shapes

            let availableIdleParticles = particles.filter(p => p.type === 'idle_random');
            availableIdleParticles.sort(() => 0.5 - Math.random()); // Shuffle for random assignment

            let particlePoolIndex = 0;

            for (let i = 0; i < NUM_SHAPES_TO_FORM; i++) {
                const shapeX = Math.random() * (width * 0.8) + (width * 0.1);
                const shapeY = Math.random() * (height * 0.8) + (height * 0.1);
                const template = basicShapeTemplates[Math.floor(Math.random() * basicShapeTemplates.length)];
                const shapeHue = (hue + i * (360 / NUM_SHAPES_TO_FORM)) % 360;
                
                const newShape = new ShapeObject(shapeX, shapeY, template, shapeHue);

                for (let j = 0; j < PARTICLES_PER_SHAPE_TARGET; j++) {
                    const shapePointDef = template.points[j % template.points.length];
                    let p;

                    if (particlePoolIndex < availableIdleParticles.length) {
                        p = availableIdleParticles[particlePoolIndex++];
                    } else {
                        // Spawn new particle near where shape will form if pool is empty
                        const spawnX = shapeX + (Math.random() - 0.5) * 50;
                        const spawnY = shapeY + (Math.random() - 0.5) * 50;
                        p = new Particle(spawnX, spawnY, {h: (shapeHue + j*5) % 360, s:100, l:70}, PARTICLE_BASE_SIZE, 'shape_forming');
                        particles.push(p); // Add to global list
                    }
                    
                    p.color.h = (shapeHue + j * (360 / PARTICLES_PER_SHAPE_TARGET / 2)) % 360;
                    p.color.s = 100;
                    p.color.l = 75;
                    newShape.addParticle(p, shapePointDef.x, shapePointDef.y);
                }
                activeShapes.push(newShape);
            }
        }

        function updateActiveShapes() {
            for (let i = activeShapes.length - 1; i >= 0; i--) {
                const shape = activeShapes[i];
                shape.update();
                if (shape.state === 'done') {
                    activeShapes.splice(i, 1);
                }
            }
             // If all shapes are done and still in idle mode, schedule new formation
            if (isIdleMode && activeShapes.length === 0 && (Date.now() - lastMouseMoveTime > MOUSE_INACTIVITY_TIMEOUT)) {
                 clearTimeout(shapeFormationTimeoutId);
                 shapeFormationTimeoutId = setTimeout(startShapesFormation, SHAPE_FORMATION_DELAY / 2); // Faster respawn
            }
        }

        // --- Animation Loop ---
        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 1)'; // Solid clear
            ctx.fillRect(0, 0, width, height);

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw();
                if (p.life <= 0 || p.size <= 0.05 || p.opacity <= 0.01) {
                    particles.splice(i, 1);
                }
            }
            
            checkIdleStatus();
            if (isIdleMode || activeShapes.length > 0) { // Update shapes if idle or if any shapes are still active (e.g. disintegrating)
                updateActiveShapes();
            }
            
            hue = (hue + 0.2) % 360; // Slower global hue shift
            requestAnimationFrame(animate);
        }

        // --- Initialization ---
        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('touchmove', (e) => { e.preventDefault(); handleMouseMove(e.touches[0])}, {passive: false});
        window.addEventListener('resize', handleResize);
        
        mouseX = width / 2;
        mouseY = height / 2;
        lastMouseMoveTime = Date.now();

        animate();
        showMessage("Move mouse/touch for droplets! Stay still for spinning shapes!", 5000);
    </script>
</body>
</html>
